hello sir, my name is mohammad shakib alam and i am from section k22sk and my roll number is 67. my registration number is 12203273.

the problem which i have got was problem number two sir, in this i have to implement a solution to tackle reader-writer problem. which is i have given a variable which is a shared variable and i have to do operations like read and write on them using thread functions and the things are that i cannot read the variable when writer thread fucntion is writing the shared variable and also i cannot write on the function when reader thread functions are running as if read and write, both are done concurrently then there will be inconsistency in the values. but readers can access the data concurrently as reading a varable doesn't changes its value and its going to be consistence in all so.

so what i have done is that i have at first included 4 header files which are stdio.h, stdlib, pthread and semphore. i have included stdio.h to use basic fucntions like printf and stdlib i have included to use random function as i am going to put threads in sleep for some time so there i am going to use the rand to put them sleep for some random time. then pthread to used threads and semophore to used mutex, locks and semaphores

then a macro of size 10, this is the max number of reader threads i am going to create at a single time as mutltiple readers can read data concurrently

then comes my data variable which i will use as my shared variable as both read and wriite thread are going to use it. writer thread function is going to increment its value by 1 and reader threads are just going to print the value of data at that curent moment whatever it is. and then mutex variable of type pthread mutex t is initialized with its defalut value which is currently unlocked. and it is going to used for readers. 

then here a semaphore varable of type sem_t is declared. which is going to give access of data structure to the threads.

then here i have declared the reader function. the function is going to read the data value and print it. but if write thread is running then it is going to wait till the write function completes. so at first when it is called, i am applying the read lock then incrementing the reader_count by 1 and if the count becomes 1 after incrementing then i am using a semaphore to wait until write function is done as when reader_count is 1, writer is running and no read operation can be done. after wating read function is going to read the value and print the data and the id of the reader thread which is currently executing then again using the lock function to release the lock. after releasing decrementing the reader_count value by 1 and the read operation is done. and also at last if the it is the last reader thread then givng access to the writer thread and at end puts the function into sleep for some random time.

after reader, writer function defination is here where i am going to increase the shared data variable value by 1. here i have also used the infinite loop as i want to run the writer thread function infinite times. so at first i am locking the mutex variable then incrementing the data value by 1 and then unlocking the mutex variable and then putting the function into sleep for some random time. as i dont want writer function to run if already any other writer or reader thread function is working on the shared variable data. after writing on the data, again putting function into sleep for some random time.

now in the main function firstly i am checking synchronization mechanisms, here semaphore rw_sem is initilized with value 1 which means 1 thread function can access the shared variable at a time. if it fails the condition then it will show a error message and exit the program. 

and then here i am creating multiple reader threads and below two writer threads. each readet thread gets a read lock and readys the shared data then releases the lock. same done by the writer thread. and the semaphore is used to ensure that only one writer can access the shared data structure and a mutex to ensure that only multiple reader can access the shared data but a writer cant.

and then the remaining code is to join the threads and destroy the mutex and semaphore variables. the first loop is used to join the reader thread and the second to join the writer thread using the thread_join function. and then destroying the mutex and semaphore variables using the destroy function.